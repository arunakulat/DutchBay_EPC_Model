# dutchbay_v13/adapters.py
from __future__ import annotations
from typing import Dict, Any, List
import math

try:
    import numpy_financial as npf  # pip install numpy-financial
except Exception:  # pragma: no cover
    npf = None

# Debt sculptor (new)
from .finance.debt import sculpt_debt_schedule


# ---------------------------- utilities ----------------------------

def _as_float(d: Dict[str, Any], k: str, default: float | None = None) -> float | None:
    v = d.get(k)
    try:
        return float(v) if v is not None else default
    except Exception:
        return default

def _irr(cashflows: List[float]) -> float:
    if npf is None or not cashflows:
        return 0.0
    try:
        r = float(npf.irr(cashflows))
        return r if math.isfinite(r) else 0.0
    except Exception:
        return 0.0

def _npv(rate: float, cashflows: List[float]) -> float:
    return sum(cf / ((1.0 + rate) ** t) for t, cf in enumerate(cashflows)) if cashflows else 0.0

def _nominal_rate(params: Dict[str, Any], default: float = 0.08) -> float:
    """
    Order of precedence:
      1) interest_rate_nominal (decimal)
      2) base_rate + margin_bps/10_000
      3) default
    """
    r = _as_float(params, "interest_rate_nominal")
    if r is not None:
        return r
    base = _as_float(params, "base_rate")
    m_bps = _as_float(params, "margin_bps")
    if base is not None and m_bps is not None:
        return base + (m_bps / 10_000.0)
    return default

def _debt_terms_present(p: Dict[str, Any]) -> bool:
    keys = (
        "debt_ratio", "tenor_years", "construction_grace_years",
        "interest_rate_nominal", "base_rate", "margin_bps",
        "target_dscr", "min_dscr", "dsra_months",
        "use_revenue_guarantee", "dscr_probability_basis", "dscr_haircut_factor",
    )
    return any(k in p for k in keys)

def _prob_basis_to_haircut(basis: str | None) -> float:
    """
    Simple CFADS haircut convention for DSCR sculpting:
      P50 → 1.00 (no haircut)
      P90 → 0.90 (conservative)
    Optional override via dscr_haircut_factor (e.g., 0.88).
    """
    if not basis:
        return 1.0
    b = basis.strip().lower()
    if b == "p90":
        return 0.90
    # Future: p75→0.95, p95→0.85, etc., if you choose to extend.
    return 1.0


# ---------------------------- main adapter ----------------------------

def run_irr_demo(params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Debt-aware IRR/DSCR adapter.

    Equity-only behavior (no debt inputs present):
      - t0 = -capex
      - Annual net = revenue - opex
      - equity_irr == project_irr, dscr_min = 1.0 if net >= 0 else 0.0

    Debt-aware behavior (any debt input present):
      - Split capex into debt/equity.
      - Build debt schedule (DSCR sculpt to target if given; else annuity after grace).
      - Optional DSRA at t0; optional receivables guarantee fee (0.75% of revenue) replaces DSRA.
      - Report levered equity IRR, unlevered project IRR, NPV@12, and dscr_min.
    """
    # ---------------- project-side inputs ----------------
    capex_usd = (_as_float(params, "capex_usd")
                 or (1e6 * (_as_float(params, "capex_musd", 0.0) or 0.0))) or 0.0

    opex_usd = (_as_float(params, "opex_usd_per_year")
                or (1e6 * (_as_float(params, "opex_musd_per_year", 0.0) or 0.0))) or 0.0

    capacity_mw = _as_float(params, "capacity_mw", 1.0) or 1.0
    lifetime = int(_as_float(params, "lifetime_years", 20) or 20)
    avail = (_as_float(params, "availability_pct", 95.0) or 95.0) / 100.0
    loss = (_as_float(params, "loss_factor", 0.0) or 0.0)

    # Tariff in USD/kWh; fallback 'tariff' treated as USD/kWh for this adapter
    tariff_usd_per_kwh = _as_float(params, "tariff_usd_per_kwh")
    if tariff_usd_per_kwh is None:
        tariff_usd_per_kwh = _as_float(params, "tariff", 0.10) or 0.10

    # Production
    mwh_year = capacity_mw * 8760.0 * avail * max(0.0, 1.0 - loss)
    kwh_year = mwh_year * 1000.0
    revenue = tariff_usd_per_kwh * kwh_year

    # Optional receivables guarantee (replaces DSRA in this simplified treatment)
    use_revenue_guarantee = bool(params.get("use_revenue_guarantee", False))
    guarantee_revenue_pct = _as_float(params, "guarantee_revenue_pct", 0.0075) or 0.0075
    # guarantee_max_months is accepted but not modeled beyond the flat fee
    _ = params.get("guarantee_max_months", 9)

    guarantee_fee = (revenue * guarantee_revenue_pct) if use_revenue_guarantee else 0.0

    # CFADS proxy for this adapter
    cfads_annual = revenue - opex_usd - guarantee_fee
    cfads_stream: List[float] = [cfads_annual for _ in range(lifetime)]

    # ---------------- equity-only fallback ----------------
    if not _debt_terms_present(params):
        annual_net = cfads_annual
        equity_series = [-capex_usd] + [annual_net] * lifetime
    # --- HARD-FAIL (auto inserted) ---
    _strict = (str(params.get("strict","")).lower() in ("1","true","yes","on")) or 
              (os.getenv("VALIDATION_MODE","").lower() == "strict") or 
              (os.getenv("DB13_STRICT_VALIDATE","0").lower() in ("1","true","yes","on"))
    try:
        _min_dscr = (params.get("Financing_Terms",{}) or {}).get("min_dscr", (params.get("Debt_Structure",{}) or {}).get("min_dscr", (params.get("Return_Constraints",{}) or {}).get("min_dscr")))
    except Exception:
        _min_dscr = None
    _balloon = float(locals().get("balloon_remaining", 0.0) or 0.0)
    _dscr_min = float(locals().get("dscr_min", 0.0) or 0.0)
    if _strict and ((_balloon > 1e-6) or (_min_dscr is not None and _dscr_min < float(_min_dscr))):
        raise ValueError(f"Strict mode: covenant breach (balloon_remaining={_balloon:.2f}, dscr_min={_dscr_min:.2f}, min_dscr={_min_dscr})")
    # --- END HARD-FAIL ---
        return {
            "equity_irr": _irr(equity_series),
            "project_irr": _irr([-capex_usd] + cfads_stream),
            "npv_12": _npv(0.12, [-capex_usd] + cfads_stream),
            "dscr_min": 1.0 if annual_net >= 0.0 else 0.0,
            "annual": [{"year": y, "equity_cf": annual_net, "dscr": 1.0 if annual_net > 0 else 0.0}
                       for y in range(1, lifetime + 1)],
        }

    # ---------------- debt-aware path ----------------
    debt_ratio = _as_float(params, "debt_ratio", 0.70) or 0.70
    tenor_years = int(_as_float(params, "tenor_years", 15) or 15)
    grace_years = int(_as_float(params, "construction_grace_years", 2) or 2)
    rate = _nominal_rate(params, default=0.08)

    target_dscr = _as_float(params, "target_dscr", 1.30)
    min_dscr = _as_float(params, "min_dscr", 1.20)
    dsra_months = int(_as_float(params, "dsra_months", 6) or 6)
    if use_revenue_guarantee:
        dsra_months = 0  # guarantee replaces DSRA here

    # DSCR probability basis → CFADS haircut for covenant calculations
    basis = params.get("dscr_probability_basis")  # 'P50' or 'P90'
    haircut = _as_float(params, "dscr_haircut_factor")
    if haircut is None:
        haircut = _prob_basis_to_haircut(basis)
    haircut = max(0.0, min(1.0, haircut))

    # Split capex at COD
    debt_amount = capex_usd * max(0.0, min(1.0, debt_ratio))
    equity_amount = capex_usd - debt_amount

    # CFADS stream for debt tenor, with haircut if any
    cfads_for_debt = (cfads_stream + [cfads_stream[-1]] * max(0, tenor_years - len(cfads_stream)))[:tenor_years]
    cfads_for_debt_hc = [c * haircut for c in cfads_for_debt]

    schedule = sculpt_debt_schedule(
        cfads_for_debt=cfads_for_debt_hc,  # use haircut values for covenanting/shape
        principal=debt_amount,
        rate=rate,
        tenor_years=tenor_years,
        grace_years=grace_years,
        target_dscr=target_dscr,
        min_dscr=min_dscr,
        method="auto",  # sculpt if target_dscr provided; else annuity
    )

    # DSRA deposit at t0 (based on first-year debt service)
    dsra_deposit = 0.0
    if dsra_months > 0:
        first_ds = schedule["debt_service"][0] if schedule["debt_service"] else 0.0
        dsra_deposit = (dsra_months / 12.0) * first_ds

    # Build equity cash flows (levered)
    equity_series: List[float] = [-(equity_amount + dsra_deposit)]
    annual_rows: List[Dict[str, float | int]] = []
    dscr_full: List[float] = []

    for y in range(1, lifetime + 1):
        ds = schedule["debt_service"][y - 1] if y <= tenor_years else 0.0
        dscr_y = schedule["dscr"][y - 1] if y <= tenor_years else (float("inf") if cfads_annual > 0 else 0.0)
        eq_cf_y = cfads_stream[y - 1] - ds
        # DSRA release in maturity year
        if dsra_deposit > 0.0 and y == tenor_years:
            eq_cf_y += dsra_deposit
        equity_series.append(eq_cf_y)
        dscr_full.append(dscr_y)
        annual_rows.append({"year": y, "equity_cf": eq_cf_y, "dscr": dscr_y})

    equity_irr = _irr(equity_series)
    project_irr = _irr([-capex_usd] + cfads_stream)  # unlevered
    npv12 = _npv(0.12, [-capex_usd] + cfads_stream)
    finite_dscr = [d for d in dscr_full if math.isfinite(d)]
    dscr_min = min(finite_dscr) if finite_dscr else 0.0

    out: Dict[str, Any] = {
        "equity_irr": equity_irr,
        "project_irr": project_irr,
        "npv_12": npv12,
        "dscr_min": dscr_min,
        "annual": annual_rows,
    }
    balloon = schedule.get("balloon_remaining", 0.0)
    if balloon and balloon > 1e-6:
        out["balloon_remaining"] = float(balloon)
    return out

    